package usecase

import (
	"fmt"
	"path/filepath"
	"time"

	"github.com/Josepavese/asdp/engine/domain"
	"gopkg.in/yaml.v3"
)

type SyncModelUseCase struct {
	fs     domain.FileSystem
	parser domain.ASTParser
	hasher domain.ContentHasher
}

func NewSyncModelUseCase(fs domain.FileSystem, parser domain.ASTParser, hasher domain.ContentHasher) *SyncModelUseCase {
	return &SyncModelUseCase{fs: fs, parser: parser, hasher: hasher}
}

type SyncResult struct {
	Path         string `json:"path"`
	SymbolsFound int    `json:"symbols_found"`
	OldHash      string `json:"old_hash"`
	NewHash      string `json:"new_hash"`
	Status       string `json:"status"` // "updated", "unchanged"
}

func (uc *SyncModelUseCase) Execute(path string) (*SyncResult, error) {
	absPath, err := validateAndExpandPath(path)
	if err != nil {
		return nil, err
	}
	path = absPath

	result := &SyncResult{Path: path}

	// 1. Calculate current Hash
	newHash, err := uc.hasher.HashDir(path)
	if err != nil {
		return nil, fmt.Errorf("failed to hash dir: %w", err)
	}
	result.NewHash = newHash

	// 2. Parse Code for Symbols
	symbols, err := uc.parser.ParseDir(path)
	if err != nil {
		return nil, fmt.Errorf("failed to parse dir: %w", err)
	}
	result.SymbolsFound = len(symbols)

	// 3. Read existing CodeModel (to preserve Body)
	modelPath := filepath.Join(path, "codemodel.md")
	var existingBody string
	var existingMeta domain.CodeModelMeta

	data, err := uc.fs.ReadFile(modelPath)
	if err == nil {
		// File exists, try to parse
		model, parseErr := parseCodeModel(data)
		if parseErr == nil {
			existingMeta = model.MetaData
			existingBody = model.Body
			result.OldHash = existingMeta.Integrity.SrcHash
		} else {
			// Exist but corrupted? Or maybe empty? Just keep body empty.
			existingBody = ""
		}
	} else {
		// New file
		existingBody = "\n# Semantic Model\n\nAuto-generated by ASDP Sync.\n"
		result.OldHash = "none"
	}

	// 4. Check if update is needed
	// strictly we update if hash changed OR symbols changed (maybe comments update?)
	// For now, let's always update to ensure correctness.

	// 5. Construct new Metadata
	newMeta := domain.CodeModelMeta{
		ASDPVersion: "1.0.0",
		Integrity: domain.Integrity{
			SrcHash:   newHash,
			Algorithm: "sha256",
			CheckedAt: time.Now(),
		},
		Symbols: symbols,
	}

	// 6. Write back to file
	// Marshal Frontmatter
	fmBytes, err := yaml.Marshal(newMeta)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal yaml: %w", err)
	}

	newContent := fmt.Sprintf("---\n%s---\n%s", string(fmBytes), existingBody)

	if err := uc.fs.WriteFile(modelPath, []byte(newContent)); err != nil {
		return nil, fmt.Errorf("failed to write file: %w", err)
	}

	result.Status = "updated"
	if result.OldHash == result.NewHash {
		result.Status = "refreshed_metadata" // Hash match but we overwrote structure anyway
	}

	return result, nil
}
