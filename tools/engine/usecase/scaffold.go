package usecase

import (
	"bytes"
	"fmt"
	"path/filepath"
	"text/template"
	"time"

	"github.com/Josepavese/asdp/engine/domain"
)

// Templates constants
const codeSpecTemplate = `---
asdp_version: "1.0.0"
id: "{{.ID}}"
type: "{{.Type}}"
title: "{{.Name}}"
summary: "TODO: Add a brief summary of this module."
capabilities: []
dependencies: []
requirements: []
exports: []
---
# {{.Name}} Specification

## Context
Describe the context and reasoning for this module here.

## Requirements
- ...
`

const codeModelTemplate = `---
asdp_version: "1.0.0"
integrity:
  src_hash: "PENDING_FIRST_SYNC"
  algorithm: "sha256"
  checked_at: {{.CheckedAt}}
symbols: []
---
# Semantic Model

Auto-generated by ASDP. Run asdp_sync to populate.
`

type ScaffoldUseCase struct {
	fs domain.FileSystem
}

type ScaffoldParams struct {
	Name string
	Type string // library, service, app
	Path string // Parent directory, default "."
}

func NewScaffoldUseCase(fs domain.FileSystem) *ScaffoldUseCase {
	return &ScaffoldUseCase{fs: fs}
}

func (uc *ScaffoldUseCase) Execute(params ScaffoldParams) (string, error) {
	// 1. Resolve Target Directory
	if params.Path == "" {
		params.Path = "."
	}
	targetDir := filepath.Join(params.Path, params.Name)

	// 2. Create Directory
	// We check if it exists by trying to Stat.
	// Actually, MkdirAll is idempotent usually, but let's check to allow "clean" start assurance?
	// For robust idempotency as requested, checking first is good, but overwriting files might be bad.
	// The user rule said "non cancella quello che l'utente ha gi√† creato".
	// So we should fail if files exist? Or skip?
	// Let's check dir existence first.
	if _, err := uc.fs.Stat(targetDir); err == nil {
		// Directory exists. We proceed but check files individually before overwriting?
		// For now, let's allow scaffolding into existing dir but NOT overwrite existing ASDP files.
	} else {
		// Create dir (FileSystem interface needs MkdirAll? RealFileSystem has manual impl or we add it)
		// Our domain.FileSystem only has WriteFile.
		// We might need to extend FileSystem interface or handle mkdir in WriteFile implication?
		// Usually WriteFile in simple FS implies creating dir.
		// Let's assume WriteFile creates dirs or we need to expand FS capability.
		// Checking fs.go: RealFileSystem.WriteFile uses ioutil.WriteFile. It does NOT create dirs.
		// We need to upgrade FS interface.
	}

	// 3. Generate Content
	specContent, err := renderTemplate(codeSpecTemplate, map[string]interface{}{
		"ID":   fmt.Sprintf("%s-%d", params.Name, time.Now().Unix()), // Simple ID generation
		"Name": params.Name,
		"Type": params.Type,
	})
	if err != nil {
		return "", err
	}

	modelContent, err := renderTemplate(codeModelTemplate, map[string]interface{}{
		"CheckedAt": time.Now().Format(time.RFC3339),
	})
	if err != nil {
		return "", err
	}

	// 4. Write Files (Safely)
	files := map[string]string{
		"codespec.md":  specContent,
		"codemodel.md": modelContent,
	}

	created := []string{}
	skipped := []string{}

	// We'll need a way to ensure dir exists.
	// IMPORTANT: I need to check `tools/engine/system/fs.go` to see if I need to add MkdirAll.
	// Assuming I need to add it to the interface.

	for filename, content := range files {
		filePath := filepath.Join(targetDir, filename)
		if _, err := uc.fs.Stat(filePath); err == nil {
			skipped = append(skipped, filename)
			continue
		}

		// Attempt write
		if err := uc.fs.WriteFile(filePath, []byte(content)); err != nil {
			return "", fmt.Errorf("failed to write %s: %w", filename, err)
		}
		created = append(created, filename)
	}

	return fmt.Sprintf("Scaffolded %s in %s. Created: %v, Skipped: %v", params.Name, targetDir, created, skipped), nil
}

func renderTemplate(tmplStr string, data interface{}) (string, error) {
	t, err := template.New("scaffold").Parse(tmplStr)
	if err != nil {
		return "", err
	}
	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		return "", err
	}
	return buf.String(), nil
}
