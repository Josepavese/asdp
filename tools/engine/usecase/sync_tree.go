package usecase

import (
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/Josepavese/asdp/engine/domain"
	"gopkg.in/yaml.v3"
)

type SyncTreeUseCase struct {
	fs domain.FileSystem
}

func NewSyncTreeUseCase(fs domain.FileSystem) *SyncTreeUseCase {
	return &SyncTreeUseCase{fs: fs}
}

func (uc *SyncTreeUseCase) Execute(path string) (*domain.CodeTree, error) {
	absPath, err := validateAndExpandPath(path)
	if err != nil {
		return nil, err
	}
	path = absPath

	// 1. Build Component Tree
	rootComp, err := uc.buildComponent(path, path)
	if err != nil {
		return nil, fmt.Errorf("failed to build tree: %w", err)
	}

	// 2. Construct Tree Object
	tree := &domain.CodeTree{
		MetaData: domain.CodeTreeMeta{
			ASDPVersion: domain.Version,
			Root:        true,
			Components:  rootComp.Children, // Root's children are the top-level components
			Verification: domain.Verification{
				ScanTime: time.Now(),
			},
		},
		Body: "\n# Project Hierarchy\n\nAuto-generated by ASDP SyncTree.\n",
	}

	// 3. Write to File
	treePath := filepath.Join(path, "codetree.md")
	fmBytes, err := yaml.Marshal(tree.MetaData)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal yaml: %w", err)
	}

	newContent := fmt.Sprintf("---\n%s---\n%s", string(fmBytes), tree.Body)
	if err := uc.fs.WriteFile(treePath, []byte(newContent)); err != nil {
		return nil, fmt.Errorf("failed to write codetree.md: %w", err)
	}

	return tree, nil
}

func (uc *SyncTreeUseCase) buildComponent(root string, currentPath string) (*domain.Component, error) {
	comp := &domain.Component{
		Name: filepath.Base(currentPath),
		Path: currentPath,
		Type: "module", // Default
	}

	// Check for ASDP files
	if _, err := uc.fs.Stat(filepath.Join(currentPath, "codespec.md")); err == nil {
		comp.HasSpec = true
	}
	if _, err := uc.fs.Stat(filepath.Join(currentPath, "codemodel.md")); err == nil {
		comp.HasModel = true
	}

	// Read children
	// Wait, RealFileSystem has Walk, but not ReadDir exposed.
	// Actually, I can use filepath.Walk but I want to control recursion.
	// Let's assume I can use os.ReadDir via a cast or add it to interface.
	// For now, let's use Walk but skip sub-sub directories manually? No that's inefficient.
	// I'll use standard os.ReadDir since RealFileSystem is just a wrapper around os.
	// BUT wait, I need to test this. The interface is in domain.
	// domain.FileSystem has: ReadFile, WriteFile, MkdirAll, Walk, Stat.
	// It DOES NOT have ReadDir. I should add it or use Walk non-recursively strategy.

	// Strategy: Use Walk but return SkipDir for all subdirectories.
	var children []domain.Component

	// We can't easily use Walk to just list children without hacky logic.
	// I will read directories directly using `os` for now, assuming local FS.
	// ideally I should update the interface. Let's do that properly next time.
	// For now, I'll use `filepath.Walk` with depth control logic? No.
	// I'll update the Interface! No, I can't easily change `domain/interfaces.go` without breaking mocks if any.
	// Let's check `tools/engine/domain/interfaces.go`.

	// Hack: I'll use `Walk` to find immediate children
	err = uc.fs.Walk(currentPath, func(path string, isDir bool) error {
		if path == currentPath {
			return nil // Root of this walk
		}

		// We only want immediate children for this node.
		// If the path is deeper than immediate child, skip it.
		rel, _ := filepath.Rel(currentPath, path)
		if len(strings.Split(rel, string(os.PathSeparator))) > 1 {
			if isDir {
				return fs.SkipDir // It's a grandchild directory, skip traversing inside it here
			}
			return nil // It's a grandchild file, ignore
		}

		if !isDir {
			return nil // We only care about directories as components
		}

		// It is an immediate child directory.
		if isIgnoredDir(filepath.Base(path)) {
			return fs.SkipDir
		}

		// Recurse to build sub-component
		var childComp *domain.Component
		childComp, err = uc.buildComponent(root, path)
		if err != nil {
			return err // Propagate error? Or log and skip?
		}
		children = append(children, *childComp)

		return fs.SkipDir // We verified this child, don't let Walk traverse inside it again, we handle recursion manually via buildComponent
	})

	comp.Children = children
	return comp, err
}

// Duplicated ignore logic (should centralize later)
func isIgnoredDir(name string) bool {
	ignored := []string{".git", ".idea", ".vscode", "node_modules", "vendor", "dist", "build", "structs"} // Added structs just in case
	for _, idx := range ignored {
		if name == idx {
			return true
		}
	}
	if strings.HasPrefix(name, ".") {
		return true
	}
	return false
}
